<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BG GEN PRO v6</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech&display=swap" rel="stylesheet">

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Share Tech', sans-serif; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        /* Canvas Wrapper untuk Rasio */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas { 
            display: block; 
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(15, 15, 20, 0.95);
            border: 1px solid #444;
            padding: 20px;
            color: #ccc;
            z-index: 1000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        body.recording #ui-panel {
            border-color: #ff3333;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.2);
        }

        /* Header Row with Gear */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        h2 { 
            margin: 0; 
            font-size: 20px; 
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .gear-btn {
            font-size: 20px;
            cursor: pointer;
            color: #888;
            transition: 0.3s;
            user-select: none;
        }
        .gear-btn:hover { color: #4facfe; transform: rotate(90deg); }

        /* General UI Elements */
        label { 
            font-size: 13px; 
            color: #888; 
            margin-bottom: 5px; 
            display: block; 
            text-transform: uppercase;
        }
        
        select, button, input {
            font-family: 'Share Tech', sans-serif;
            width: 100%;
            padding: 10px;
            margin-bottom: 12px;
            background: #1a1a1a;
            color: #fff;
            font-size: 16px;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
            box-sizing: border-box; 
            text-transform: capitalize;
        }

        select:hover, button:hover { border-color: #666; background: #252525; }
        select:focus, input:focus { outline: none; border-color: #4facfe; }

        /* Timer Row Layout (50:50) */
        .timer-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        .timer-row select { width: 50%; margin-bottom: 0; }
        .timer-display {
            width: 50%;
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 0 10px;
            text-align: right;
            font-size: 20px;
            color: #4facfe;
            border-radius: 4px;
            letter-spacing: 1px;
            box-sizing: border-box;
            height: 42px; /* Fixed height match select */
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        #customTimeInput { display: none; margin-top: -5px; border-color: #4facfe; color: #4facfe; }

        /* Buttons Colors */
        button#btnPause { background: #2a2a2a; color: #ffa500; border-color: #553300; }
        button#btnPause.paused { background: #ffa500; color: #000; animation: blink 1s infinite; }
        
        button#btnRecord { background: #111; color: #4facfe; border-color: #1e3a8a; font-weight: bold; margin-bottom: 0; }
        button#btnRecord.recording { background: #ff3333; color: #fff; border-color: #990000; }

        button#btnBack { background: #333; color: #fff; margin-top: 10px;}

        .status { font-size: 12px; text-align: center; color: #666; margin-top: 10px; text-transform: uppercase;}

        /* Panel Visibility Logic */
        .panel-section { display: block; animation: fadeIn 0.3s; }
        .hidden { display: none; }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="header-row">
            <h2>System Control</h2>
            <div class="gear-btn" id="btnGear" title="Settings">âš™</div>
        </div>
        
        <div id="main-controls" class="panel-section">
            <label>Category</label>
            <select id="categorySelect">
                <option value="animation">Background Animation</option>
                <option value="motion">Active Motion</option>
            </select>

            <label>Visual Style</label>
            <select id="styleSelect">
                </select>

            <label>Color Palette</label>
            <select id="paletteSelect">
                <option value="hacker">Hacker Green</option>
                <option value="cyber">Cyberpunk Neon</option>
                <option value="vapor">Vaporwave Retro</option>
                <option value="crimson">Crimson Red</option>
                <option value="royal">Royal Gold</option>
                <option value="toxic">Toxic Lime (New)</option>
                <option value="deepspace">Deep Space (New)</option>
                <option value="candy">Candy Pop (New)</option>
                <option value="luxury">Luxury Gold</option>
                <option value="arctic">Arctic White</option>
                <option value="midnight">Midnight Blue</option>
                <option value="sunset">Sunset Vibes</option>
                <option value="dark">Dark Matter</option>
            </select>

            <button id="btnRefresh">Randomize</button>
            <button id="btnPause">Pause</button>
            <button id="btnRecord">Start Recording</button>
            <div class="status" id="statusText">Ready</div>
        </div>

        <div id="settings-controls" class="panel-section hidden">
            <label>Output Ratio</label>
            <select id="ratioSelect">
                <option value="fullscreen">Full Screen (Device)</option>
                <option value="1:1">1:1 (Square/Post)</option>
                <option value="9:16">9:16 (Story/Tiktok)</option>
                <option value="16:9">16:9 (Landscape/YT)</option>
            </select>

            <label>Recording Timer</label>
            <div class="timer-row">
                <select id="durationSelect">
                    <option value="manual">Manual</option>
                    <option value="5000">5 Sec</option>
                    <option value="8000">8 Sec</option>
                    <option value="10000">10 Sec</option>
                    <option value="15000">15 Sec</option>
                    <option value="custom">Custom</option>
                </select>
                <div class="timer-display" id="timerDisplay">00.00</div>
            </div>
            <input type="number" id="customTimeInput" placeholder="Seconds...">

            <button id="btnBack">Back To Main</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // --- DATA STRUCTURES ---
        const styleData = {
            animation: [
                { id: 'aurora', name: 'Soft Aurora' },
                { id: 'ripples', name: 'Rain Ripples' },
                { id: 'dna', name: 'DNA Helix' },
                { id: 'hex', name: 'Hexagon Grid' },
                { id: 'nebula', name: 'Nebula Cloud' },
                { id: 'bokeh', name: 'Floating Bokeh' },
                { id: 'waves', name: 'Sine Waves' },
                { id: 'grid', name: 'Retro Floor' }
            ],
            motion: [
                { id: 'vortex', name: 'Hyper Vortex' },
                { id: 'matrix', name: 'Digital Rain' },
                { id: 'audio', name: 'Audio Spectrum' },
                { id: 'glitch', name: 'Glitch Noise' },
                { id: 'shooting', name: 'Shooting Stars' },
                { id: 'rings', name: 'Hypno Rings' },
                { id: 'starwarp', name: 'Star Warp' },
                { id: 'network', name: 'Neural Grid' }
            ]
        };

        const palettes = {
            hacker:   ['#000000', '#001100', '#00ff00', '#33ff33', '#ccffcc'],
            luxury:   ['#0a0a0a', '#1a1a1a', '#d4af37', '#f1c40f', '#fff8dc'],
            arctic:   ['#0f172a', '#1e293b', '#e0f2fe', '#bae6fd', '#7dd3fc'],
            midnight: ['#020617', '#172554', '#3b82f6', '#60a5fa', '#93c5fd'],
            sunset:   ['#2d0f1f', '#4a1c40', '#db2777', '#f97316', '#fbbf24'],
            dark:     ['#000000', '#111111', '#444444', '#666666', '#888888'],
            cyber:    ['#050014', '#12002e', '#fceE0a', '#00f0ff', '#ff003c'],
            vapor:    ['#181026', '#2b1030', '#ff71ce', '#01cdfe', '#05ffa1'],
            crimson:  ['#000000', '#1a0505', '#8a0000', '#ff0000', '#ff4d4d'],
            royal:    ['#120024', '#2a0040', '#800080', '#ffd700', '#ffffae'],
            toxic:    ['#0d0d0d', '#1a1a1a', '#ccff00', '#99cc00', '#eeffaa'],
            deepspace:['#000000', '#0a0a1a', '#4b0082', '#8a2be2', '#ffffff'],
            candy:    ['#220011', '#440022', '#ff66b2', '#00ccff', '#ffff00']
        };

        // --- APP STATE ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        const state = {
            category: 'animation',
            style: 'aurora',
            palette: 'hacker',
            ratio: 'fullscreen',
            objects: []
        };

        let width, height;
        let animationId;
        let frameCount = 0;
        let isPaused = false;

        // --- DOM ELEMENTS ---
        const categorySelect = document.getElementById('categorySelect');
        const styleSelect = document.getElementById('styleSelect');
        const paletteSelect = document.getElementById('paletteSelect');
        const ratioSelect = document.getElementById('ratioSelect');
        const mainControls = document.getElementById('main-controls');
        const settingsControls = document.getElementById('settings-controls');

        // --- INITIALIZATION ---

        function populateStyles() {
            styleSelect.innerHTML = '';
            const list = styleData[state.category];
            list.forEach(item => {
                const opt = document.createElement('option');
                opt.value = item.id;
                opt.textContent = item.name;
                styleSelect.appendChild(opt);
            });
            // Set first option active
            state.style = list[0].id;
        }

        function updateRatio() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            
            let targetW = winW;
            let targetH = winH;

            if (state.ratio === '1:1') {
                const size = Math.min(winW, winH) * 0.9;
                targetW = size; targetH = size;
            } else if (state.ratio === '9:16') {
                targetH = winH * 0.9;
                targetW = targetH * (9/16);
            } else if (state.ratio === '16:9') {
                targetW = winW * 0.9;
                targetH = targetW * (9/16);
            }

            canvas.width = targetW;
            canvas.height = targetH;
            canvas.style.width = targetW + 'px';
            canvas.style.height = targetH + 'px';
            
            width = targetW;
            height = targetH;
            initScene();
        }

        window.addEventListener('resize', updateRatio);

        // --- SCENE LOGIC ---

        function initScene() {
            state.objects = [];
            frameCount = 0;
            const colors = palettes[state.palette];
            
            // GENERAL BLUR SETTING
            if(state.style === 'aurora' || state.style === 'nebula') {
                canvas.style.filter = 'blur(60px)';
            } else {
                canvas.style.filter = 'none';
            }

            // INIT BASED ON STYLE
            switch(state.style) {
                case 'matrix':
                    const fontSize = 16;
                    for (let x = 0; x < width / fontSize; x++) {
                        state.objects.push({ x: x * fontSize, y: Math.random() * height, speed: 2 + Math.random() * 3 });
                    }
                    break;
                case 'aurora':
                case 'nebula':
                    for(let i=0; i<6; i++) {
                        state.objects.push({ 
                            x: Math.random() * width, 
                            y: Math.random() * height, 
                            vx: (Math.random() - 0.5), 
                            vy: (Math.random() - 0.5), 
                            r: Math.min(width, height) / 2, 
                            color: colors[Math.floor(Math.random()*(colors.length-1))+1] 
                        });
                    }
                    break;
                case 'starwarp':
                    for(let i=0; i<200; i++) state.objects.push({ x: Math.random()*width, y: Math.random()*height, z: Math.random()*width });
                    break;
                case 'bokeh':
                    for(let i=0; i<40; i++) state.objects.push({ x: Math.random()*width, y: Math.random()*height+50, vy: -0.5-Math.random(), r: 10+Math.random()*50, color: colors[Math.floor(Math.random()*(colors.length-1))+1], alpha: Math.random()*0.5 });
                    break;
                case 'vortex':
                    for(let i=0; i<300; i++) state.objects.push({ angle: Math.random() * Math.PI * 2, radius: Math.random() * width, speed: 0.02 + Math.random() * 0.03, color: colors[Math.floor(Math.random()*colors.length)] });
                    break;
                case 'ripples':
                     state.objects.push({ x: width/2, y: height/2, r: 0, alpha: 1, color: colors[2] });
                     break;
                case 'glitch':
                    // Dynamic generation
                    break;
            }
        }

        function animate() {
            if (isPaused) return;

            const colors = palettes[state.palette];
            
            // Background clearing strategy
            let alpha = 'ff'; // Default opaque
            if (['matrix', 'starwarp', 'shooting', 'vortex', 'audio'].includes(state.style)) alpha = '33'; // Trails
            if (state.style === 'ripples' || state.style === 'glitch') alpha = '22';

            ctx.fillStyle = colors[0] + alpha;
            ctx.fillRect(0, 0, width, height);

            frameCount++;

            switch (state.style) {
                case 'aurora': renderAurora(); break;
                case 'nebula': renderNebula(); break;
                case 'matrix': renderMatrix(); break;
                case 'rings': renderRings(); break;
                case 'starwarp': renderStarWarp(); break;
                case 'network': renderNetwork(); break;
                case 'bokeh': renderBokeh(); break;
                case 'waves': renderWaves(); break;
                case 'grid': renderGrid(); break;
                case 'ripples': renderRipples(); break;
                case 'dna': renderDNA(); break;
                case 'shooting': renderShooting(); break;
                case 'hex': renderHex(); break;
                case 'vortex': renderVortex(); break;
                case 'glitch': renderGlitch(); break;
                case 'audio': renderAudio(); break;
            }
            animationId = requestAnimationFrame(animate);
        }

        // --- RENDERERS ---

        function renderVortex() {
            const cx = width/2; const cy = height/2;
            state.objects.forEach(p => {
                p.angle += p.speed;
                p.radius -= 0.5;
                if(p.radius < 0) p.radius = Math.max(width, height);
                const x = cx + Math.cos(p.angle) * p.radius;
                const y = cy + Math.sin(p.angle) * p.radius;
                ctx.fillStyle = p.color;
                ctx.fillRect(x, y, 2, 2);
            });
        }

        function renderGlitch() {
            const colors = palettes[state.palette];
            if(Math.random() > 0.8) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const w = Math.random() * 200;
                const h = Math.random() * 50;
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.fillRect(x, y, w, h);
            }
            // Noise lines
            for(let i=0; i<5; i++) {
                ctx.fillStyle = colors[1];
                ctx.fillRect(0, Math.random()*height, width, 2);
            }
        }

        function renderAudio() {
            const colors = palettes[state.palette];
            const bars = 50;
            const barW = width / bars;
            for(let i=0; i<bars; i++) {
                // Fake audio data using sinewaves
                const h = Math.abs(Math.sin(frameCount * 0.1 + i * 0.2)) * (height/2);
                ctx.fillStyle = colors[2 + (i%3)];
                ctx.fillRect(i * barW, height/2 - h/2, barW - 2, h);
            }
        }

        function renderNebula() {
            // Similar to Aurora but more chaotic
            state.objects.forEach(b => {
                b.x += Math.sin(frameCount*0.01 + b.vx)*2; 
                b.y += Math.cos(frameCount*0.01 + b.vy)*2;
                if(b.x < -b.r) b.x = width+b.r; if(b.x > width+b.r) b.x = -b.r;
                if(b.y < -b.r) b.y = height+b.r; if(b.y > height+b.r) b.y = -b.r;
                ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fillStyle = b.color; ctx.fill();
            });
        }

        function renderMatrix() {
            const colors = palettes[state.palette];
            ctx.font = '16px "Share Tech"'; ctx.fillStyle = colors[2];
            state.objects.forEach(drop => {
                const chars = "01XYZAOBK"; ctx.fillText(chars.charAt(Math.floor(Math.random() * chars.length)), drop.x, drop.y);
                drop.y += drop.speed; if (drop.y > height && Math.random() > 0.98) drop.y = 0;
            });
        }
        function renderAurora() {
            state.objects.forEach(b => {
                b.x += b.vx; b.y += b.vy;
                if(b.x < -b.r || b.x > width + b.r) b.vx *= -1; if(b.y < -b.r || b.y > height + b.r) b.vy *= -1;
                ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fillStyle = b.color; ctx.fill();
            });
        }
        function renderRings() {
            const colors = palettes[state.palette]; ctx.lineWidth = 2; const cx = width / 2; const cy = height / 2;
            for(let i=0; i<15; i++) {
                const r = (frameCount * 2 + i * 80) % (Math.max(width, height)/1.2);
                const alpha = 1 - (r / (Math.max(width, height)/1.2));
                ctx.strokeStyle = colors[2]; ctx.globalAlpha = alpha; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
            } ctx.globalAlpha = 1;
        }
        function renderStarWarp() {
            const colors = palettes[state.palette]; ctx.fillStyle = colors[colors.length-1]; const cx = width/2; const cy = height/2;
            state.objects.forEach(star => {
                star.z -= 10; if (star.z <= 0) { star.z = width; star.x = Math.random() * width; star.y = Math.random() * height; }
                const sx = (star.x - cx) * (width / star.z) + cx; const sy = (star.y - cy) * (width / star.z) + cy;
                const size = (1 - star.z / width) * 4; ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI * 2); ctx.fill();
            });
        }
        function renderNetwork() {
            const colors = palettes[state.palette]; ctx.lineWidth = 0.5; ctx.strokeStyle = colors[2];
            for(let i=0; i<40; i++) {
                const x = (Math.sin(frameCount*0.01 + i)*width/2) + width/2;
                const y = (Math.cos(frameCount*0.02 + i)*height/2) + height/2;
                ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fillStyle = colors[2]; ctx.fill();
                // Connect logic simplified for performance
                if(i>0) { ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo((Math.sin(frameCount*0.01 + (i-1))*width/2) + width/2, (Math.cos(frameCount*0.02 + (i-1))*height/2) + height/2); ctx.stroke(); }
            }
        }
        function renderBokeh() {
            state.objects.forEach(p => {
                p.y += p.vy; if (p.y < -p.r) { p.y = height + p.r; p.x = Math.random() * width; }
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.globalAlpha = p.alpha; ctx.fill();
            }); ctx.globalAlpha = 1;
        }
        function renderWaves() {
            const colors = palettes[state.palette]; ctx.lineWidth = 2;
            for(let i=1; i<colors.length; i++) {
                ctx.strokeStyle = colors[i]; ctx.beginPath();
                for(let x=0; x<width; x+=20) { const y = height/2 + Math.sin(x*0.01 + frameCount*0.02 + i)*60; if(x===0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
                ctx.stroke();
            }
        }
        function renderGrid() {
            const colors = palettes[state.palette]; const gridSize = 60; const offset = (frameCount * 2) % gridSize;
            ctx.strokeStyle = colors[2]; ctx.lineWidth = 1; const horizon = height * 0.4;
            for(let x=-width; x<width*2; x+=gridSize) { ctx.beginPath(); ctx.moveTo(width/2, horizon); ctx.lineTo(x, height); ctx.globalAlpha = 0.2; ctx.stroke(); }
            for(let y=horizon; y<height; y+=gridSize - (y/height)*20) {
                 const drawY = y + offset * (y/height); if(drawY > height) continue;
                 ctx.beginPath(); ctx.moveTo(0, drawY); ctx.lineTo(width, drawY); ctx.stroke();
            } ctx.globalAlpha = 1;
        }
        function renderRipples() {
            const colors = palettes[state.palette]; ctx.lineWidth = 2;
            if (frameCount % 15 === 0) state.objects.push({ x: Math.random()*width, y: Math.random()*height, r: 0, alpha: 1, color: colors[Math.floor(Math.random()*(colors.length-1))+1] });
            for(let i = state.objects.length - 1; i >= 0; i--) {
                const p = state.objects[i]; p.r += 2; p.alpha -= 0.01;
                if(p.alpha <= 0) state.objects.splice(i, 1);
                else { ctx.strokeStyle = p.color; ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.stroke(); }
            } ctx.globalAlpha = 1;
        }
        function renderDNA() {
            const colors = palettes[state.palette]; const cx = width / 2;
            for(let i=0; i<40; i++) {
                const y = (height/40)*i; const t = frameCount * 0.05 + y * 0.01;
                const x1 = cx + Math.sin(t) * 100; const x2 = cx + Math.sin(t + Math.PI) * 100;
                ctx.strokeStyle = colors[2]; ctx.globalAlpha = 0.2; ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
                ctx.globalAlpha = 1; ctx.fillStyle = colors[3]; ctx.beginPath(); ctx.arc(x1, y, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = colors[4]; ctx.beginPath(); ctx.arc(x2, y, 4, 0, Math.PI*2); ctx.fill();
            }
        }
        function renderShooting() {
            const colors = palettes[state.palette]; ctx.strokeStyle = colors[colors.length-1]; ctx.lineWidth = 2;
            if(state.objects.length === 0) { // lazy init
                for(let i=0; i<15; i++) state.objects.push({ x: Math.random()*width, y: Math.random()*height, l: Math.random()*50+20, s: Math.random()*15+5 });
            }
            state.objects.forEach(s => {
                s.x -= s.s; s.y += s.s;
                if (s.x < -100 || s.y > height + 100) { s.x = Math.random() * width + 200; s.y = -100; }
                ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x + s.l, s.y - s.l); ctx.stroke();
            });
        }
        function renderHex() {
            const colors = palettes[state.palette]; const size = 50; const h = size * Math.sqrt(3); const w = size * 2; const dx = w * 0.75;
            ctx.lineWidth = 1; ctx.strokeStyle = colors[2];
            for (let x = 0; x < width + size; x += dx) {
                const colIdx = Math.round(x/dx); const yOffset = (colIdx % 2 === 1) ? h/2 : 0;
                for (let y = -size; y < height + size; y += h) {
                    const drawY = y + yOffset; const dist = Math.hypot(x - width/2, drawY - height/2);
                    const alpha = (Math.sin(dist * 0.01 - frameCount * 0.05) + 1) / 2 * 0.5;
                    ctx.globalAlpha = Math.max(0.1, alpha);
                    ctx.beginPath(); for (let i = 0; i < 6; i++) { const ang = (Math.PI/3)*i; ctx[i===0?'moveTo':'lineTo'](x+size*Math.cos(ang), drawY+size*Math.sin(ang)); } ctx.closePath(); ctx.stroke();
                }
            } ctx.globalAlpha = 1;
        }

        // --- UI & INTERACTION ---

        // Randomizer Logic (Smart Random)
        document.getElementById('btnRefresh').addEventListener('click', () => {
            // 1. Get available styles for current category
            const styles = styleData[state.category];
            const randomStyle = styles[Math.floor(Math.random() * styles.length)];
            
            // 2. Get random palette
            const keys = Object.keys(palettes);
            const randomPalette = keys[Math.floor(Math.random() * keys.length)];

            // 3. Apply
            state.style = randomStyle.id;
            state.palette = randomPalette;
            
            // 4. Update UI
            styleSelect.value = state.style;
            paletteSelect.value = state.palette;
            
            initScene();
        });

        // Category Switcher Logic
        categorySelect.addEventListener('change', (e) => {
            state.category = e.target.value;
            populateStyles(); // Refresh dropdown list
            initScene();
        });

        styleSelect.addEventListener('change', (e) => { state.style = e.target.value; initScene(); });
        paletteSelect.addEventListener('change', (e) => { state.palette = e.target.value; initScene(); });
        ratioSelect.addEventListener('change', (e) => { state.ratio = e.target.value; updateRatio(); });

        // Settings Panel Toggle
        const btnGear = document.getElementById('btnGear');
        const btnBack = document.getElementById('btnBack');
        
        function toggleSettings() {
            mainControls.classList.toggle('hidden');
            settingsControls.classList.toggle('hidden');
        }

        btnGear.addEventListener('click', toggleSettings);
        btnBack.addEventListener('click', toggleSettings);


        // --- TIME & RECORDING (Same logic, new UI location) ---
        const btnPause = document.getElementById('btnPause');
        btnPause.addEventListener('click', () => {
            isPaused = !isPaused;
            btnPause.classList.toggle('paused');
            btnPause.textContent = isPaused ? "Resume" : "Pause";
        });

        const durationSelect = document.getElementById('durationSelect');
        const customTimeInput = document.getElementById('customTimeInput');
        const timerDisplay = document.getElementById('timerDisplay');
        const btnRecord = document.getElementById('btnRecord');
        const statusText = document.getElementById('statusText');
        
        let mediaRecorder;
        let chunks = [];
        let isRecording = false;
        let recordingStartTime;
        let timerInterval;

        durationSelect.addEventListener('change', (e) => {
            customTimeInput.style.display = e.target.value === 'custom' ? 'block' : 'none';
        });

        btnRecord.addEventListener('click', () => {
            if(!isRecording) {
                if(isPaused) btnPause.click(); 
                startRec();
            } else {
                stopRec();
            }
        });

        function startRec() {
            let targetDuration = -1; 
            const val = durationSelect.value;
            if (val === 'custom') {
                const secs = parseInt(customTimeInput.value);
                if (secs && secs > 0) targetDuration = secs * 1000;
            } else if (val !== 'manual') {
                targetDuration = parseInt(val);
            }

            const stream = canvas.captureStream(30);
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
            mediaRecorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
            mediaRecorder.onstop = saveVid;
            mediaRecorder.start();
            
            isRecording = true;
            recordingStartTime = Date.now();
            
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - recordingStartTime;
                updateTimerUI(elapsed);
                if (targetDuration > 0 && elapsed >= targetDuration) stopRec();
            }, 16); 

            document.body.classList.add('recording');
            btnRecord.textContent = "Stop";
            btnRecord.classList.add('recording');
            statusText.textContent = "Recording...";
        }

        function stopRec() {
            if (!isRecording) return;
            mediaRecorder.stop();
            isRecording = false;
            clearInterval(timerInterval);
            updateTimerUI(0);
            document.body.classList.remove('recording');
            btnRecord.textContent = "Start Recording";
            btnRecord.classList.remove('recording');
            statusText.textContent = "Processing...";
        }

        function updateTimerUI(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const milliseconds = Math.floor((ms % 1000) / 10);
            timerDisplay.textContent = `${totalSeconds.toString().padStart(2,'0')}.${milliseconds.toString().padStart(2,'0')}`;
        }

        function saveVid() {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `BG_GEN_${state.style}_${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            chunks = [];
            statusText.textContent = "Saved.";
        }

        // Start App
        populateStyles();
        updateRatio();
        animate();

    </script>
</body>
</html>
